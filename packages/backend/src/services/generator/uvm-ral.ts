import type { Project, Register, Field, AddressBlock } from "@register-manager/shared";
import { parseNumber, toHex, sanitizeIdentifier, getFieldAccess } from "@register-manager/shared";

interface UVMRALOptions {
  packageName?: string;
  includeComments?: boolean;
  baseClassName?: string;
}

/**
 * Generate UVM RAL (Register Abstraction Layer) from IP-XACT project
 */
export function generateUVMRAL(project: Project, options: UVMRALOptions = {}): string {
  const {
    packageName = `${sanitizeIdentifier(project.name)}_ral_pkg`,
    includeComments = true,
    baseClassName = "uvm_reg_block",
  } = options;

  const lines: string[] = [];

  // Package header
  lines.push(`//`);
  lines.push(`// UVM RAL Package: ${project.displayName || project.name}`);
  lines.push(`// VLNV: ${project.vlnv.vendor}:${project.vlnv.library}:${project.vlnv.name}:${project.vlnv.version}`);
  lines.push(`//`);
  lines.push(`// Auto-generated by Register Manager`);
  lines.push(`// Generated: ${new Date().toISOString()}`);
  lines.push(`//`);
  lines.push("");

  lines.push(`package ${packageName};`);
  lines.push("");
  lines.push(`  import uvm_pkg::*;`);
  lines.push(`  \`include "uvm_macros.svh"`);
  lines.push("");

  // Generate field classes
  const allFields = new Set<string>();
  project.memoryMaps?.forEach((mm) => {
    mm.addressBlocks?.forEach((ab) => {
      ab.registers?.forEach((reg) => {
        reg.fields?.forEach((field) => {
          const fieldClassName = `${sanitizeIdentifier(reg.name)}_${sanitizeIdentifier(field.name)}_field`;
          if (!allFields.has(fieldClassName)) {
            allFields.add(fieldClassName);
            generateFieldClass(field, reg, fieldClassName, lines, includeComments);
          }
        });
      });
    });
  });

  // Generate register classes
  project.memoryMaps?.forEach((mm) => {
    mm.addressBlocks?.forEach((ab) => {
      ab.registers?.forEach((reg) => {
        generateRegisterClass(reg, lines, includeComments);
      });
    });
  });

  // Generate register block classes
  project.memoryMaps?.forEach((mm) => {
    mm.addressBlocks?.forEach((ab) => {
      generateRegisterBlock(ab, project, lines, includeComments, baseClassName);
    });
  });

  // Package footer
  lines.push(`endpackage : ${packageName}`);
  lines.push("");

  return lines.join("\n");
}

function generateFieldClass(
  field: Field,
  register: Register,
  className: string,
  lines: string[],
  includeComments?: boolean
) {
  if (includeComments && field.description) {
    lines.push(`  // ${field.description}`);
  }

  lines.push(`  class ${className} extends uvm_reg_field;`);
  lines.push(`    \`uvm_object_utils(${className})`);
  lines.push("");
  lines.push(`    function new(string name = "${className}");`);
  lines.push(`      super.new(name, ${field.bitWidth}, UVM_NO_COVERAGE);`);
  lines.push(`    endfunction`);
  lines.push("");
  lines.push(`    virtual function void build();`);

  const access = getFieldAccess(field);
  const uvmAccess = mapAccessToUVM(access);
  const resetValue = field.resets?.[0]?.value || "0";
  const hasReset = field.resets && field.resets.length > 0 ? "1" : "0";

  lines.push(`      configure(this.get_parent(), ${field.bitWidth}, ${field.bitOffset}, "${uvmAccess}", ${field.volatile ? "1" : "0"}, ${resetValue}, ${hasReset}, 1, 0);`);
  lines.push(`    endfunction`);
  lines.push(`  endclass`);
  lines.push("");
}

function generateRegisterClass(
  register: Register,
  lines: string[],
  includeComments?: boolean
) {
  const className = `${sanitizeIdentifier(register.name)}_reg`;

  if (includeComments) {
    lines.push(`  //`);
    lines.push(`  // Register: ${register.displayName || register.name}`);
    if (register.description) {
      lines.push(`  // ${register.description}`);
    }
    lines.push(`  // Offset: ${register.addressOffset}`);
    lines.push(`  // Size: ${register.size} bits`);
    lines.push(`  //`);
  }

  lines.push(`  class ${className} extends uvm_reg;`);
  lines.push(`    \`uvm_object_utils(${className})`);
  lines.push("");

  // Declare fields
  register.fields?.forEach((field) => {
    const fieldName = sanitizeIdentifier(field.name).toLowerCase();
    const fieldClassName = `${sanitizeIdentifier(register.name)}_${sanitizeIdentifier(field.name)}_field`;
    lines.push(`    rand ${fieldClassName} ${fieldName};`);
  });
  lines.push("");

  // Constructor
  lines.push(`    function new(string name = "${className}");`);
  lines.push(`      super.new(name, ${register.size}, UVM_NO_COVERAGE);`);
  lines.push(`    endfunction`);
  lines.push("");

  // Build function
  lines.push(`    virtual function void build();`);
  register.fields?.forEach((field) => {
    const fieldName = sanitizeIdentifier(field.name).toLowerCase();
    const fieldClassName = `${sanitizeIdentifier(register.name)}_${sanitizeIdentifier(field.name)}_field`;
    lines.push(`      ${fieldName} = ${fieldClassName}::type_id::create("${fieldName}");`);
    lines.push(`      ${fieldName}.configure(this, null, "");`);
    lines.push(`      ${fieldName}.build();`);
  });
  lines.push(`    endfunction`);
  lines.push(`  endclass`);
  lines.push("");
}

function generateRegisterBlock(
  addressBlock: AddressBlock,
  project: Project,
  lines: string[],
  includeComments?: boolean,
  baseClassName?: string
) {
  const blockName = `${sanitizeIdentifier(addressBlock.name)}_reg_block`;
  const baseAddr = parseNumber(addressBlock.baseAddress);

  if (includeComments) {
    lines.push(`  //`);
    lines.push(`  // Register Block: ${addressBlock.displayName || addressBlock.name}`);
    if (addressBlock.description) {
      lines.push(`  // ${addressBlock.description}`);
    }
    lines.push(`  // Base Address: ${toHex(baseAddr, 8)}`);
    lines.push(`  //`);
  }

  lines.push(`  class ${blockName} extends ${baseClassName || "uvm_reg_block"};`);
  lines.push(`    \`uvm_object_utils(${blockName})`);
  lines.push("");

  // Declare registers
  addressBlock.registers?.forEach((reg) => {
    const regName = sanitizeIdentifier(reg.name).toLowerCase();
    const regClassName = `${sanitizeIdentifier(reg.name)}_reg`;
    lines.push(`    rand ${regClassName} ${regName};`);
  });
  lines.push("");

  // Constructor
  lines.push(`    function new(string name = "${blockName}");`);
  lines.push(`      super.new(name, UVM_NO_COVERAGE);`);
  lines.push(`    endfunction`);
  lines.push("");

  // Build function
  lines.push(`    virtual function void build();`);
  lines.push(`      default_map = create_map("default_map", ${toHex(baseAddr, 8)}, ${addressBlock.width / 8}, UVM_LITTLE_ENDIAN);`);
  lines.push("");

  addressBlock.registers?.forEach((reg) => {
    const regName = sanitizeIdentifier(reg.name).toLowerCase();
    const regClassName = `${sanitizeIdentifier(reg.name)}_reg`;
    const offset = parseNumber(reg.addressOffset);

    lines.push(`      ${regName} = ${regClassName}::type_id::create("${regName}");`);
    lines.push(`      ${regName}.configure(this, null, "");`);
    lines.push(`      ${regName}.build();`);
    lines.push(`      default_map.add_reg(${regName}, ${toHex(offset, 8)}, "${mapAccessToUVM(getFieldAccess(reg.fields?.[0] || {} as Field))}");`);
    lines.push("");
  });

  lines.push(`      lock_model();`);
  lines.push(`    endfunction`);
  lines.push(`  endclass`);
  lines.push("");
}

function mapAccessToUVM(access: string): string {
  switch (access) {
    case "read-write":
      return "RW";
    case "read-only":
      return "RO";
    case "write-only":
      return "WO";
    default:
      return "RW";
  }
}
