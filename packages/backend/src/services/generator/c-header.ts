import type { Project, Register, Field, AddressBlock } from "@register-manager/shared";
import { parseNumber, toHex, sanitizeIdentifier, toScreamingSnakeCase } from "@register-manager/shared";

interface CHeaderOptions {
  includeGuard?: string;
  includeComments?: boolean;
  includeStructs?: boolean;
  includeMacros?: boolean;
  bitfieldStyle?: "macros" | "structs";
}

/**
 * Generate C header file from IP-XACT project
 */
export function generateCHeader(project: Project, options: CHeaderOptions = {}): string {
  const {
    includeGuard = `${sanitizeIdentifier(project.name)}_H`,
    includeComments = true,
    includeStructs = true,
    includeMacros = true,
    bitfieldStyle = "macros",
  } = options;

  const lines: string[] = [];

  // Header guard start
  lines.push(`#ifndef ${includeGuard}`);
  lines.push(`#define ${includeGuard}`);
  lines.push("");

  // File header comment
  if (includeComments) {
    lines.push("/**");
    lines.push(` * @file ${project.name}.h`);
    lines.push(` * @brief ${project.displayName || project.name}`);
    if (project.description) {
      lines.push(` * @description ${project.description}`);
    }
    lines.push(` * @vlnv ${project.vlnv.vendor}:${project.vlnv.library}:${project.vlnv.name}:${project.vlnv.version}`);
    lines.push(" * ");
    lines.push(" * Auto-generated by Register Manager");
    lines.push(` * Generated: ${new Date().toISOString()}`);
    lines.push(" */");
    lines.push("");
  }

  // Standard includes
  lines.push("#include <stdint.h>");
  lines.push("");

  // Process each memory map
  project.memoryMaps?.forEach((memoryMap) => {
    if (includeComments) {
      lines.push("/*" + "=".repeat(78));
      lines.push(` * Memory Map: ${memoryMap.displayName || memoryMap.name}`);
      if (memoryMap.description) {
        lines.push(` * ${memoryMap.description}`);
      }
      lines.push(" " + "=".repeat(78) + "*/");
      lines.push("");
    }

    memoryMap.addressBlocks?.forEach((addressBlock) => {
      generateAddressBlockDefinitions(addressBlock, lines, { includeComments, includeMacros, includeStructs, bitfieldStyle });
    });
  });

  // Header guard end
  lines.push(`#endif /* ${includeGuard} */`);
  lines.push("");

  return lines.join("\n");
}

function generateAddressBlockDefinitions(
  addressBlock: AddressBlock,
  lines: string[],
  options: { includeComments?: boolean; includeMacros?: boolean; includeStructs?: boolean; bitfieldStyle?: string }
) {
  const { includeComments, includeMacros, includeStructs, bitfieldStyle } = options;
  const baseAddr = parseNumber(addressBlock.baseAddress);
  const blockName = sanitizeIdentifier(addressBlock.name);

  if (includeComments) {
    lines.push("/*" + "-".repeat(78));
    lines.push(` * Address Block: ${addressBlock.displayName || addressBlock.name}`);
    if (addressBlock.description) {
      lines.push(` * ${addressBlock.description}`);
    }
    lines.push(` * Base Address: ${toHex(baseAddr, 8)}`);
    lines.push(` * Range: ${addressBlock.range}`);
    lines.push(" " + "-".repeat(78) + "*/");
    lines.push("");
  }

  // Base address macro
  if (includeMacros) {
    lines.push(`#define ${blockName}_BASE_ADDR ${toHex(baseAddr, 8)}U`);
    lines.push("");
  }

  // Register offset macros
  if (includeMacros) {
    addressBlock.registers?.forEach((register) => {
      const regName = toScreamingSnakeCase(register.name);
      const offset = parseNumber(register.addressOffset);
      const absAddr = baseAddr + offset;

      if (includeComments && register.description) {
        lines.push(`/** ${register.description} */`);
      }
      lines.push(`#define ${blockName}_${regName}_OFFSET ${toHex(offset, 4)}U`);
      lines.push(`#define ${blockName}_${regName}_ADDR   ${toHex(absAddr, 8)}U`);

      // Field macros
      if (bitfieldStyle === "macros") {
        register.fields?.forEach((field) => {
          generateFieldMacros(field, `${blockName}_${regName}`, lines, includeComments);
        });
      }

      lines.push("");
    });
  }

  // Register struct
  if (includeStructs) {
    lines.push(`typedef struct {`);

    addressBlock.registers
      ?.sort((a, b) => parseNumber(a.addressOffset) - parseNumber(b.addressOffset))
      .forEach((register) => {
        const regName = register.name.toLowerCase();
        const sizeType = getSizeType(register.size);

        if (includeComments && register.description) {
          lines.push(`    /** ${register.description} */`);
        }
        lines.push(`    ${sizeType} ${regName};`);
      });

    lines.push(`} ${blockName}_regs_t;`);
    lines.push("");

    // Pointer macro
    lines.push(`#define ${blockName}_REGS ((volatile ${blockName}_regs_t*)${blockName}_BASE_ADDR)`);
    lines.push("");
  }
}

function generateFieldMacros(
  field: Field,
  prefix: string,
  lines: string[],
  includeComments?: boolean
) {
  const fieldName = toScreamingSnakeCase(field.name);
  const mask = (1 << field.bitWidth) - 1;
  const shiftedMask = mask << field.bitOffset;

  if (includeComments && field.description) {
    lines.push(`/** ${field.description} */`);
  }

  lines.push(`#define ${prefix}_${fieldName}_POS    ${field.bitOffset}U`);
  lines.push(`#define ${prefix}_${fieldName}_MASK   ${toHex(shiftedMask, 8)}U`);

  if (field.bitWidth === 1) {
    lines.push(`#define ${prefix}_${fieldName}_BIT    (1U << ${field.bitOffset})`);
  }

  // Helper macros for getting/setting field values
  lines.push(`#define ${prefix}_${fieldName}_GET(reg) (((reg) & ${prefix}_${fieldName}_MASK) >> ${prefix}_${fieldName}_POS)`);
  lines.push(`#define ${prefix}_${fieldName}_SET(reg, val) ((reg) = ((reg) & ~${prefix}_${fieldName}_MASK) | (((val) << ${prefix}_${fieldName}_POS) & ${prefix}_${fieldName}_MASK))`);
}

function getSizeType(bits: number): string {
  if (bits <= 8) return "uint8_t ";
  if (bits <= 16) return "uint16_t";
  if (bits <= 32) return "uint32_t";
  if (bits <= 64) return "uint64_t";
  return `uint8_t[${Math.ceil(bits / 8)}]`;
}
